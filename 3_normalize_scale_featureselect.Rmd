---
title: "Data normalization, scaling, and feature selection"
author: "Angelo Pelonero"
date: "6/3/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Normalizing the data:

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method “LogNormalize” that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in pbmc[["RNA"]]@data.
```{r}
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
```
For clarity, in this previous line of code (and in future commands), we provide the default values for certain parameters in the function call. However, this isn’t required and the same behavior can be achieved with:
```{r}
pbmc <- NormalizeData(pbmc)
# what else can I do with this function?
?NormalizeData
```

### Identification of highly variable features (feature selection):

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). We and others have found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.

Our procedure in Seurat3 is described in detail here, and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures function. By default, we return 2,000 features per dataset. These will be used in downstream analysis, like PCA.
```{r}
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
#CombinePlots(plots = list(plot1, plot2))
# Note that you can combine plots, but for clarity let's look at each one on their own:
plot1
plot2
#You can ignore the error message 'Transformation introduced infinite values in continuous x-axis'
```

### Scaling the data:

Next, we apply a linear transformation (‘scaling’) that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData function:

  - Shifts the expression of each gene, so that the mean expression across cells is 0
  - Scales the expression of each gene, so that the variance across cells is 1
  - This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate
  - The results of this are stored in pbmc[["RNA"]]@scale.data
```{r}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes, vars.to.regress = "percent.mt")
```
This can take some time...

What if it's too slow? Can we make it faster?

Scaling is an essential step in the Seurat workflow, but only on genes that will be used as input to PCA. Therefore, the default in ScaleData is only to perform scaling on the previously identified variable features (2,000 by default). To do this, omit the features argument in the previous function call, i.e.

```{r}
#commented out so this code does not run, see reason above this cell
#pbmc <- ScaleData(pbmc)
```
If you do perfrom scaling on only the 2000 variable genes, your PCA and clustering results will be unaffected. However, Seurat heatmaps (produced as shown below with DoHeatmap) require genes in the heatmap to be scaled, to make sure highly-expressed genes don’t dominate the heatmap. To make sure we don’t leave any genes out of the heatmap later, we are scaling all genes in this tutorial.

### Confounding variation regression:

In Seurat v2 we could also use the ScaleData() function to remove unwanted sources of variation from a single-cell dataset. We could ‘regress out’ heterogeneity associated with (for example) cell cycle stage, mitochondrial contamination, or integrating two 10X libraries run on different chips/different days. These features are still supported in ScaleData in Seurat v3, but keep in mind that it is essentially deprecated and likely will not be a part of future Seurat releases. An example of using the new regression is below.

```{r}
#pbmc <- SCTransform(pbmc, vars.to.regress = "percent.mt", return.only.var.genes = FALSE, verbose = FALSE)
```
The Seurat developers strongly recommend the use of the new normalization workflow, SCTransform. The method is described in their recent preprint, with a separate vignette using Seurat v3 here: https://satijalab.org/seurat/v3.0/sctransform_vignette.html. As with ScaleData, you can direct the function SCTransform to regress uninteresting variation with the `vars.to.regress` parameter.

The `SCTransform` step actually replaces `NormalizeData`, `ScaleData`, and `FindVariableFeatures`.